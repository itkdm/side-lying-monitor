

## 项目评估

- **前台/后台姿态检测逻辑重复，易失衡**  
  当前在 Flutter 层 `_startSensorListening` 与 `_maybeTriggerReminder` 实现了一套传感器+计时逻辑，同时 Android 原生 `FloatingWindowService` 里又复制了一份基本相同的检测与提醒流程。这不仅让 bug 修复、阈值/算法调整需要改两遍，也容易出现状态不同步（例如前台已“翻身”，但后台服务仍判定为侧躺）  

```705:809:lib/main.dart
void _startSensorListening() {
  _accelSub = accelerometerEvents.listen((event) {
    ...
  });
  _checkTimer = Timer.periodic(const Duration(seconds: 1), (_) {
    _maybeTriggerReminder();
  });
}
```

```206:307:android/app/src/main/kotlin/com/example/flutter_application_1/FloatingWindowService.kt
override fun onSensorChanged(event: SensorEvent?) { ... }
private fun startReminderCheck() {
  reminderCheckHandler?.postDelayed(this, 1000)
}
```

  **改进建议**：抽象一个姿态检测/提醒的共享模块（例如用 `MethodChannel` 将 Dart 侧判定委托给原生服务，或把核心算法封装成 Dart plugin），统一状态机与提醒节奏，并通过事件通道把结果广播给 UI。

- **`flutter_background_service` 仅初始化，从未真正启动**  
  `main` 中只调用 `_initializeBackgroundService` 做配置，代码库里没有任何 `service.startService()` 或 `service.invoke` 的触发，因此插件不会实际运行，所有后台能力都落在原生服务身上  

```75:104:lib/main.dart
void main() {
  WidgetsFlutterBinding.ensureInitialized();
  _initializeBackgroundService();
  runApp(const PostureGuardianApp());
}
Future<void> _initializeBackgroundService() async {
  final service = FlutterBackgroundService();
  await service.configure(...);
}
```

  **改进建议**：要么删掉未使用的依赖以降低复杂度；要么在监测开关打开时真正启动 Flutter 后台服务，并决定与原生服务的角色分工，避免两套方案混杂。

- **用户设置未完整同步到原生服务**  
  Kotlin 服务里虽然定义了 `isInDnd`，但从未在提醒逻辑中调用，震动也不受 `_vibrationEnabled` 控制，导致后台提醒会无视免打扰与震动开关  

```415:425:android/app/src/main/kotlin/com/example/flutter_application_1/FloatingWindowService.kt
private fun isInDnd(now: Long, dndStartMinutes: Int, dndEndMinutes: Int): Boolean { ... }
```

```321:409:android/app/src/main/kotlin/com/example/flutter_application_1/FloatingWindowService.kt
private fun checkAndTriggerReminder() {
  ...
  // 未读取 dnd_start_minutes / dnd_end_minutes / vibration_enabled
  vibrator?.vibrate(...)
  showReminderNotification()
}
```

  **改进建议**：在服务启动时或设置变更时，通过 `SharedPreferences` 或 `MethodChannel` 将免打扰与震动配置同步给服务，并在 `checkAndTriggerReminder` 里使用；否则会影响最终用户体验。

- **每秒重新实例化 SharedPreferences，存在性能隐患**  
  前台 `Timer.periodic` 每秒都 `await SharedPreferences.getInstance()` 并 `reload` 一遍磁盘，后台服务也频繁读写同一存储，容易造成 I/O 抖动及卡顿  

```219:289:lib/main.dart
checkTimer = Timer.periodic(const Duration(seconds: 1), (timer) async {
  final currentPrefs = await SharedPreferences.getInstance();
  ...
});
```

  **改进建议**：将 `SharedPreferences` 预先缓存为单例，或改为只在设置变更时写入、在进入后台/回到前台时同步一次；统计数据可考虑使用 `ValueNotifier`/BLoC 持久化，再定期 flush。

- **WakeLock 管理不完善**  
  `FloatingWindowService` 创建了 `renewWakeLock()` 但从未调用，`startSensorListening` 只在注册时申请 10 分钟锁，没有续期或在重启后恢复，可能导致长时间后台监测被系统挂起  

```188:195:android/app/src/main/kotlin/com/example/flutter_application_1/FloatingWindowService.kt
private fun renewWakeLock() {
  wakeLock?.let {
    if (it.isHeld) it.release()
    it.acquire(10*60*1000L)
  }
}
```

  **改进建议**：在定时任务里调用 `renewWakeLock()` 或换成 `setExactAndAllowWhileIdle` + `AlarmManager` 机制，同时在 `onDestroy`/`ACTION_HIDE` 时可靠地释放。

- **`lib/main.dart` 体积过大、职责过多**  
  单文件接近 2k 行，`_RootShellState` 同时承担 UI、权限、传感器、通知、统计、本地存储、悬浮窗调度等职责，维护成本高、测试困难  

```354:1056:lib/main.dart
class _RootShellState extends State<RootShell> with WidgetsBindingObserver {
  // 监测状态、设置、传感器、悬浮窗、通知、UI 全部堆在这里
}
```

  **改进建议**：按领域拆分（如 `services/posture_monitor.dart`, `pages/home.dart`, `settings/settings_controller.dart`），引入 `ChangeNotifier`/`Riverpod` 等状态管理，让 UI 只消费已加工的数据。

## 可行的改进方向

- **统一后台策略**：明确只使用原生前台服务，或只用 `flutter_background_service`，或者让两者互为主备；如果继续依赖悬浮窗服务，可把 Flutter 里冗余的后台定时器移除，以免重复提醒。
- **设置与数据同步**：抽象一个 `SettingsRepository`，在 Dart 改动时给原生发送广播；原生更新统计后也应该以事件形式传回 Flutter，而不是双方各自读写 `SharedPreferences`。
- **性能优化**：降低传感器监听频率（例如 `SENSOR_DELAY_UI`）、在后台改用 `SensorManager.registerListener` 的 batching；`Timer.periodic` 可改 `Stream.periodic` 并复用 `SharedPreferences`。
- **权限与可用性**：Manifest 里声明了 `REQUEST_IGNORE_BATTERY_OPTIMIZATIONS`，但应用内没有弹窗引导；建议在开启监测时提示用户加入白名单，否则国内 ROM 可能杀死服务。
- **质量保障**：补充最少的 widget 测试/传感器算法单元测试，验证“持续 X 秒后提醒”“免打扰不提醒”“阈值调整生效”等核心流程；并在 `docs/` 中描述架构和原生联动方式，方便交付/扩展。

若你希望我聚焦在某个模块（例如只聊原生服务或 UI 设计），可以告诉我，我可以进一步细化。